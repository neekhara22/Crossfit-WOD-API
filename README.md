# Crossfit-WOD-API

              
<html>
   <main class="content" role="main">
        <article class="post">





<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#architecture">Architecture</a></li>
<li><a href="#basic-setup">Basic Setup</a></li>
<li><a href="#versioning">Versioning</a></li>
<li><a href="#respond-with-standard-http-error-codes">Respond with standard HTTP Error Codes</a></li>
<li><a href="#group-associated-resources-together-logical-nesting-">Group associated resources together</a></li>
<li><a href="#integrate-filtering-sorting-pagination">Integrate filtering, sorting &amp; pagination</a></li>
<li><a href="#use-data-caching-for-performance-improvements">Use data caching for performance improvements</a></li>
<li><a href="#document-your-api-properly">Document your API properly</a></li>
</ul>
  </div>
  </figcaption>
  </figure>
  <p>I build a REST API for a CrossFit Training Application. If you're not familiar with CrossFit, it's a fitness method and competitive sport that combines high-intensity workouts with elements from several sports (olympic weightlifting, gymnastics, and others).</p>
  <p>I'd like to create, read, update and delete <strong>WOD</strong>'s (<strong>W</strong>orkouts <strong>o</strong>f the <strong>D</strong>ay)</p>
    <h3 id="architecture">Architecture</h3>
    <p>I'll be using Express.js for our API. I don't want to come up with a complex architecture so I'd like to stick to the<strong> 3 Layer Architecture:</strong></p>
 <figure class="kg-card kg-image-card"><amp-img alt="Bildschirmfoto-2022-04-25-um-14.33.24-1" class="i-amphtml-layout-responsive i-amphtml-layout-size-defined i-amphtml-element i-amphtml-built" height="400" i-amphtml-layout="responsive" layout="responsive" src="https://www-freecodecamp-org.cdn.ampproject.org/i/s/www.freecodecamp.org/news/content/images/2022/04/Bildschirmfoto-2022-04-25-um-14.33.24-1.png" srcset="https://www-freecodecamp-org.cdn.ampproject.org/i/s/www.freecodecamp.org/news/content/images/size/w600/2022/04/Bildschirmfoto-2022-04-25-um-14.33.24-1.png 600w, https://www-freecodecamp-org.cdn.ampproject.org/i/s/www.freecodecamp.org/news/content/images/2022/04/Bildschirmfoto-2022-04-25-um-14.33.24-1.png 937w" width="600" i-amphtml-auto-lightbox-visited=""><i-amphtml-sizer slot="i-amphtml-svc" style="display:block;padding-top:66.6667%;"></i-amphtml-sizer><img class="i-amphtml-blurry-placeholder" placeholder="" src="data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http%3A//www.w3.org/2000/svg' xmlns%3Axlink='http%3A//www.w3.org/1999/xlink' viewBox='0 0 9 6'%3E%3Cfilter id='b' color-interpolation-filters='sRGB'%3E%3CfeGaussianBlur stdDeviation='.5'%3E%3C/feGaussianBlur%3E%3CfeComponentTransfer%3E%3CfeFuncA type='discrete' tableValues='1 1'%3E%3C/feFuncA%3E%3C/feComponentTransfer%3E%3C/filter%3E%3Cimage filter='url(%23b)' x='0' y='0' height='100%25' width='100%25' xlink%3Ahref='data%3Aimage/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAkAAAAGCAAAAAA0rOsZAAAAMUlEQVQI1wXBgQnAQAwDMe8/bZ881HZ6UEkwxRcE6alBtHv2KyKvHQexyU0X4c4zNT8tpzShR6c3xQAAAABJRU5ErkJggg=='%3E%3C/image%3E%3C/svg%3E" i-amphtml-auto-lightbox-visited=""></amp-img></figure>
<p>Inside the <strong>Controller</strong> I'll be handling all stuff that is related to HTTP. That means we're dealing with requests and responses for our endpoints. Above that layer is also a little <strong>Router</strong> from Express that passes requests to the corresponding controller.</p><p>The whole business logic will be in the<strong> Service Layer</strong> that exports certain services (methods) which are used by the controller.</p><p>The third layer is the <strong>Data Access Layer</strong> where we'll be working with our Database. We'll be exporting some methods for certain database operations like creating a WOD that can be used by our Service Layer.</p><p>In this example we're using a local JSON file that mimics our Database. But this logic can be transferred to other databases of course.</p><h3 id="basic-setup">Basic Setup</h3><p>Now I should be ready to create a basic setup for our API. </p><p>First, let's create the overall folder structure with all necessary files and dependencies. </p><pre><code class="language-bash"># Create project folder &amp; navigate into it
mkdir crossfit-wod-api &amp;&amp; cd crossfit-wod-api</code></pre><pre><code class="language-bash"># Create a src folder &amp; navigate into it
mkdir src &amp;&amp; cd src</code></pre><pre><code class="language-bash"># Create sub folders
mkdir controllers &amp;&amp; mkdir services &amp;&amp; mkdir database &amp;&amp; mkdir routes</code></pre><pre><code class="language-bash"># Create an index file (entry point of our API)
touch index.js</code></pre><pre><code class="language-bash"># We're currently in the src folder, so we need to move one level up first 
cd .. 
Create package.json file 

npm init -y</code></pre><p>Install dependencies for the basic setup:</p><pre><code class="language-bash"># Dev Dependencies 
npm i -D nodemon 
Dependencies 

npm i express</code></pre><p>Open the project up in your favorite Text Editor and configure Express</p><p>Integrate a new script called <strong>"dev"</strong> inside package.json:</p><p>The script makes sure that the development server restarts automatically when we make changes (thanks to nodemon).</p><p>Spin up the development server:</p><pre><code class="language-bash">npm run dev</code></pre><h3 id="versioning">Versioning</h3><p>Wait a second. Before we write any API-specific code we should be aware of versioning. Like in other applications there will be improvements, new features, and stuff like that. So it's important to version our API as well.</p><p>The big advantage is that we can work on new features or improvements on a new version while the clients are still using the current version and are not affected by breaking changes.</p><p>We also don't force the clients to use the new version straight away. They can use the current version and migrate on their own when the new version is stable.</p><p>The current and new versions are basically running in parallel and don't affect each other.</p><p>That's what we expose to the outside world and what can be consumed by other developers. But we also need to structure our project in order to differentiate between each version.</p><p>There are many different approaches to handling versioning inside an Express API. In our case I'd like to create a sub folder for each version inside our <strong>src</strong> directory called <strong>v1</strong>.</p><pre><code class="language-bash">mkdir src/v1</code></pre><p>Now we move our routes folder into that new v1 directory.</p><pre><code class="language-bash"># Get the path to your current directory (copy it) 
pwd 

Move "routes" into "v1" (insert the path from above into {pwd}) 
mv {pwd}/src/routes {pwd}/src/v1</code></pre><h3 id="accept-and-respond-with-data-in-json-format">Accept and respond with data in JSON format</h3><p>When interacting with an API, I send specific data with your request or you receive data with the response. There are many different data formats but JSON (Javascript Object Notation) is a standardized format.</p><p>First, we create our service layer. After that inside our workout controller we can use these methods, Our controller layer talks now with our service layer.</p><p>Inside our service methods we'll be handling our business logic like transforming data structures and communicating with our Database Layer.</p><p>To do that, we need a database and a collection of methods that actually handle the database interaction. Our database will be a simple JSON file that is pre-filled with some workouts already.</p><p>Let's start with the simplest one and return all workouts that are stored and start with implementing the corresponding method inside our Data Access Layer (src/database/Workout.js).</p><p>Returning all workouts is pretty simple and I don't have to do transformations because it's already a JSON file.<p>Go to <strong>localhost:3434/api/v1/workouts</strong> inside your browser and you should see the response JSON.</p><p>I'm sending back data in JSON format. But what about accepting it? Let's think about an endpoint where we need to receive JSON data from the client. The endpoint for creating or updating a workout needs data from the client.</p><p>Inside our workout controller we extract the request body for creating a new workout and we pass it on to the workout service. Inside the workout service we'll insert it into our DB.json and send the newly created workout back to the client.</p><p>To be able to parse the sent JSON inside the request body, we need to install <strong>body-parser</strong> first and configure it.</p><pre><code class="language-bash">npm i body-parser</code></pre><p>As there are some properties missing like "id", "createdAt" and "updatedAt". That's the job of our API to add those properties before inserting it.</p><p>That was smooth! The next step is to use the database methods inside our workout service.</p><pre><code class="language-bash"># Install the uuid package 
npm i uuid</code></pre><h3 id="respond-with-standard-http-error-codes">Respond with standard HTTP Error Codes</h3><p>API has the ability now to handle basic CRUD operations with data storage. That's great, but not really ideal.</p><p>In a perfect world everything works smoothly without any errors. But in the real world a lot of errors can happen â€“&nbsp;either from a human or a technical perspective.</p><p>When something goes wrong (either from the request or inside our API) we send HTTP Error codes back. I've seen and used API's that were returning all the time a 400 error code. it's always a good practice to return proper HTTP error codes for different cases. In our Crossfit API I took a look at the creation endpoint and see what errors might arise and how we can handle them.<p>I already caught the case that the request body is not built up properly and got missing keys that we expect. This would be a good to send back a 400 HTTP error with a corresponding error message. I like to wrap all these thing in a try/catch block to catch the error when it occurs. An error consists of two things, a status and a message. I'm using just the <strong>throw</strong> keyword here to send out a different data structure than a string, which is required in <strong>throw new Error()</strong>. Now we're able to throw and catch errors.</p><h3 id="group-associated-resources-together-logical-nesting-">Group associated resources together (logical nesting)</h3><p>When designing API, there might be cases where resources that are associated with others. It's good to group them together into one endpoint and nest them properly.</p><p>In API, I also have a list of members that are signed up in our CrossFit box ("box" is the name for a CrossFit gym). In order to motivate members I track the overall box records for each workout. For example, there is a workout where you have to do a certain order of exercises as quickly as possible. We record the times for all members to have a list of the time for each member who completed this workout. Now, the frontend needs an endpoint that responds with all records for a specific workout in order to display it in the UI. The workouts, the members, and the records are stored in different places in the database.</p><p>To move on in architecture I create another controller, another service, and another collection of database methods that are responsible for records. I implement CRUD endpoints for the records as well, because records should be added, updated or deleted in the future as well.</p><pre><code class="language-bash"># Create records controller 
touch src/controllers/recordController.js 

Create records service 
touch src/services/recordService.js 

Create records database methods 
touch src/database/Record.js</code></pre><h3 id="integrate-filtering-sorting-pagination">Integrate filtering, sorting &amp; pagination</h3><p>Right now I'm able to do quite a few operations with API but there's more. The overall performance of our API is another key factor we should work on. That's why integrating filtering, sorting, and pagination is also an essential factor. Filtering, as the name already says, is useful because it allows us to get specific data out of our whole collection. Pagination is another mechanism to split our whole collection of workouts into multiple "pages" where each page only consists of twenty workouts. Sorting can be a complex task. So it's more effective to do it in API and to send the sorted data to the client.I integrated some filtering mechanism into our API. I upgrade our endpoint that sends all workouts by accepting filter parameters. </p><h3 id="use-data-caching-for-performance-improvements">Use data caching for performance improvements</h3><p>Using a data cache is also helpful to improve the overall experience and performance of API.</p><p>It makes a lot of sense to use a cache to serve data from, when the data is an often requested resource or/and querying that data from the database is a heavy lift and may take multiple seconds.We can store this type of data inside our cache and serve it from there instead of going to the database every time to query the data.One important thing we have to keep in mind when serving data from a cache is that this data can become outdated. So we have to make sure that the data inside the cache is always up to date.</p><p>There are many different solutions out there. I go with <strong>apicache</strong>.</p><p>First install the middleware then have to import it into workout router and configure it.</p><p>There's one <strong>important</strong> thing I'd like to note here when it comes to caching. While it seems to solve a lot of problems, it also can bring some problems into application.</p><p>A few things we have to be aware of when using a cache:</p><ul><li>we always have to make sure that the data inside the cache is up to date because we don't want to serve outdated data </li><li>while the first request is being processed and the cache is about to be filled and more requests are coming in, we have to decide if we delay those other requests and serve the data from the cache or if they also receive data straight from the database like the first request</li><h3 id="document-your-api-properly">Document your API properly</h3><p>Some people say:</p><blockquote>"An API is just as good as it's documentation"</blockquote><p>There's a lot truth in this statement because if an API is not well documented it can't be used properly and therefore becomes useless. The documentation helps make developers' lives a lot easier, too. The documentation is usually the first interaction consumers have with API. The faster users can understand the documentation, the faster they can use the API.</p><p>There are some great tools out there that make our lives easier. I use the <a href="https://www.npmjs.com/package/swagger-ui-express" target="_top">swagger-ui-express</a> and <a href="https://www.npmjs.com/package/swagger-jsdoc" target="_top">swagger-jsdoc</a> packages to accomplish this.</p><pre><code class="language-bash"># Install required npm packages 
npm i swagger-jsdoc swagger-ui-express 

Create a new file to setup the swagger docs 
touch src/v1/swagger.js</code></pre><p>Documenting endpoints also helps us to understand them better and "forces" us to think of anything you might have forgotten to implement. I've just created the full documentation for one endpoint. </p>
</body></html>
